import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

export async function generateTodo(cwd: string): Promise<void> {
  const summaryPath = path.join(cwd, 'coverage/coverage-summary.json');
  const finalPath = path.join(cwd, 'coverage/coverage-final.json');

  if (!(await fs.pathExists(summaryPath)) || !(await fs.pathExists(finalPath))) {
    console.error('No coverage data found.');
    return;
  }

  // const summary = await fs.readJSON(summaryPath); // Unused
  const final = await fs.readJSON(finalPath);
  let md =
    '# üìù Coverage TODO List\n\nGenerated by Cocov. Use this list to reach 100% coverage.\n\n';

  let hasGaps = false;

  for (const [file, cov] of Object.entries(final)) {
    const relPath = path.relative(cwd, file);
    // const s = (cov as any).lines || (cov as any).s || {}; // Unused

    const missingLines: number[] = [];
    // const missingBranches = []; // Unused

    // Logic to extract missing lines (if s[id] === 0)
    // This is complex, but let's try basic missing lines
    // For 'final' json, usually structured as: { path:..., statementMap:..., s:... }

    const f = cov as { statementMap: Record<string, { start: { line: number } }>; s: Record<string, number> };
    if (f.statementMap && f.s) {
      for (const [id, count] of Object.entries(f.s)) {
        if (count === 0) {
          const range = f.statementMap[id];
          missingLines.push(range.start.line);
        }
      }
    }

    if (missingLines.length > 0) {
      hasGaps = true;
      md += `## üî¥ ${relPath}\n`;
      md += `- [ ] Missing Lines: ${[...new Set(missingLines)].sort((a, b) => a - b).join(', ')}\n`;
    }
  }

  if (!hasGaps) {
    md += '## ‚úÖ All clear! 100% Coverage achieved.';
  }

  await fs.writeFile(path.join(cwd, 'TODO_TESTS.md'), md);
  console.log(chalk.green('‚úî Generated TODO_TESTS.md'));
}

// Self-execute if run directly
if (process.argv[1] === import.meta.url) {
  generateTodo(process.cwd());
}
